name: make-manual

permissions:
  contents: write

on:
  push:
    branches: [master]
  workflow_dispatch:
    inputs:
      publish:
        description: 'Upload to GitHub Release?'
        required: false
        default: 'false'   # 手动触发默认不发布
        type: choice
        options: ['false','true']
        
env:
  # Customize the CMake build type here (Release, Debug, RelWithDebInfo, etc.)
  BUILD_TYPE: Release

jobs:
  create_release:
    if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.publish == 'true')
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      tag: ${{ steps.tag_release.outputs.new_tag }}
    steps:
      - name: GitHub Tag
        id: tag_release
        # You may pin to the exact commit or the version.
        # uses: mathieudutour/github-tag-action@1bab3ab0712cafa42b54c512453487b89bb06504
        uses: mathieudutour/github-tag-action@v6.1
        with:
          # Required for permission to tag the repo.
          github_token: ${{ secrets.GITHUB_TOKEN }}
          # Which type of bump to use when none explicitly provided (default: `patch`).
          # default_bump: # optional, default is patch

      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # This token is provided by Actions, you do not need to create your own token
        with:
          tag_name: ${{ steps.tag_release.outputs.new_tag }}
          release_name: Release ${{ steps.tag_release.outputs.new_tag }}
          draft: false
          prerelease: false

  manylinux-build:
    # needs: [create_release]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include: 
          - name: gfortran
            container: manylinux2014_x86_64
            compiler: gfortran
            makefile: Makefile.am

    # container:
    #   image: quay.io/pypa/${{ matrix.container }}

    steps:
      - uses: actions/checkout@v4

      - name: Build & test inside manylinux
        uses: addnab/docker-run-action@v3
        with:
          image: quay.io/pypa/${{ matrix.container }}
          options: -v ${{ github.workspace }}:/work -w /work
          run: |
            set -eux
            yum install -y zip python3-pip python3-devel
            # git clone https://github.com/MingjieJian/SMElib .
            
            # Replace Makefile (optinal)
            if [ "${{ matrix.makefile }}" != "Makefile.am" ]; then
              rm -f Makefile.am 
              mv "${{ matrix.makefile }}" Makefile.am
            fi
            ./bootstrap
            ./configure --prefix=$PWD
            make install
            
            # Copy libgfortran
            if [ "${{ matrix.compiler }}" = "gfortran" ]; then
              make -s flib_target
              cp -v "$(readlink -f "$(make -s flib_source)")" "$(make -s flib_target)"
            fi
            ls -l lib
            zip -r "${{ matrix.container }}-${{ matrix.name }}.zip" lib share

      - name: Test library
        run: |
            pip3 install -r test/requirements.txt
            cd pymodule
            python setup.py build_ext --inplace
            cd ..
            python -m pytest

      # - name: Copy libgfortran
      #   if: matrix.compiler == 'gfortran'
      #   run: |
      #     ls -l $(dirname $(make -s flib_source))
      #     make -s flib_target
      #     cp -v $(readlink -f $(make -s flib_source)) $(make -s flib_target)

      # - run: ls lib
      # - run: zip -r ${{ matrix.container }}-${{ matrix.name }} lib share

      # - name: Upload Debug Spectrum
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: debug_radiative_transfer_${{ matrix.container }}-${{ matrix.name }}.npz
      #     path: ./debug_radiative_transfer.npz

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.name }}          
          path: |
            ./*.zip
            ./debug_radiative_transfer.npz
            ./sme_synth.stdout.txt
            ./sme_synth.params
          if-no-files-found: ignore

      - name: Upload Release Asset
        if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.publish == 'true')
        id: upload-release-asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create_release.outputs.upload_url }} # This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps
          asset_path: ./${{ matrix.name }}.zip
          asset_name: ${{ matrix.name }}.zip
          asset_content_type: application/zip

  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: ubuntu-gfortran
            runs_on: ubuntu-latest
            packages: gfortran python3-dev
            outputs: lib share
            makefile: Makefile.am
          - name: windows-gfortran
            runs_on: ubuntu-latest
            packages: gfortran mingw-w64 mingw-w64-tools mingw-w64-common gfortran-mingw-w64 gfortran-mingw-w64-x86-64 gcc-mingw-w64 gcc-mingw-w64-x86-64 g++-mingw-w64 g++-mingw-w64-x86-64 python3-dev
            cxx: x86_64-w64-mingw32-gcc
            f77: x86_64-w64-mingw32-gfortran
            config_flags: --build=x86_64-pc-linux-gnu --host=x86_64-w64-mingw32
            outputs: bin share
            makefile: Makefile.am
          - name: macos-intel-gfortran
            runs_on: macos-13
            arch: x86_64
            packages: automake libtool gcc
            outputs: lib share
            makefile: Makefile.am
          - name: macos-arm64-gfortran
            runs_on: macos-15
            arch: arm64
            packages: automake libtool gcc
            outputs: lib share
            makefile: Makefile.am

    # The CMake configure and build commands are platform agnostic and should work equally
    # well on Windows or Mac.  You can convert this to a matrix build if you need
    # cross-platform coverage.
    # See: https://docs.github.com/en/free-pro-team@latest/actions/learn-github-actions/managing-complex-workflows#using-a-build-matrix
    runs-on: ${{ matrix.runs_on }}
      
    steps:
      - uses: actions/checkout@v2

      - name: Install packages (Ubuntu)
        if: matrix.runs_on == 'ubuntu-latest'
        run: sudo apt-get install -y ${{ matrix.packages }}

      - name: Install packages (MacOS)
        if: matrix.runs_on == 'macos-13' || matrix.runs_on == 'macos-15'
        run: |
          brew update
          brew tap ${{ matrix.taps }}
          brew install ${{ matrix.packages }}
      - name: Select GNU compilers (macOS)
        if: matrix.runs_on == 'macos-13' || matrix.runs_on == 'macos-15'
        run: |
          BREW_PREFIX="$(brew --prefix)"
          # gfortran 通常有无版本号两个名字，取到主版本号以匹配 gcc/g++
          FVER="$($BREW_PREFIX/bin/gfortran -dumpversion | cut -d. -f1 || echo 14)"
          echo "CC=$BREW_PREFIX/bin/gcc-$FVER"       >> $GITHUB_ENV
          echo "CXX=$BREW_PREFIX/bin/g++-$FVER"      >> $GITHUB_ENV
          # gfortran 可能有无版本号，可都尝试
          if [ -x "$BREW_PREFIX/bin/gfortran-$FVER" ]; then
            echo "FC=$BREW_PREFIX/bin/gfortran-$FVER" >> $GITHUB_ENV
            echo "F77=$BREW_PREFIX/bin/gfortran-$FVER" >> $GITHUB_ENV
          else
            echo "FC=$BREW_PREFIX/bin/gfortran" >> $GITHUB_ENV
            echo "F77=$BREW_PREFIX/bin/gfortran" >> $GITHUB_ENV
          fi
          # 架构与最小系统版本：按矩阵 arch 区分
          if [ "${{ matrix.arch }}" = "x86_64" ]; then
            echo "CFLAGS=-O3 -arch x86_64 -mmacosx-version-min=11.0"   >> $GITHUB_ENV
            echo "CXXFLAGS=-O3 -arch x86_64 -mmacosx-version-min=11.0" >> $GITHUB_ENV
            echo "FFLAGS=-O3 -arch x86_64 -mmacosx-version-min=11.0"   >> $GITHUB_ENV
            echo "LDFLAGS=-arch x86_64 -mmacosx-version-min=11.0"      >> $GITHUB_ENV
          else
            echo "CFLAGS=-O3 -arch arm64 -mmacosx-version-min=12.0"    >> $GITHUB_ENV
            echo "CXXFLAGS=-O3 -arch arm64 -mmacosx-version-min=12.0"  >> $GITHUB_ENV
            echo "FFLAGS=-O3 -arch arm64 -mmacosx-version-min=12.0"    >> $GITHUB_ENV
            echo "LDFLAGS=-arch arm64 -mmacosx-version-min=12.0"       >> $GITHUB_ENV
          fi

      - name: Replace Makefile.am
        if: matrix.makefile != 'Makefile.am'
        run: |
          rm Makefile.am
          mv ${{ matrix.makefile }} Makefile.am

      - name: Run Bootstrap, Configure and install (Ubuntu)
        if: matrix.runs_on == 'ubuntu-latest'
        env:
          CXX: ${{ matrix.cxx }}
          F77: ${{ matrix.f77 }}
        run: |
          ./bootstrap 
          ./configure --prefix=$PWD ${{ matrix.config_flags }}
          make install

      - name: Run Bootstrap, Configure and install (MacOS)
        if: matrix.runs_on == 'macos-13' || matrix.runs_on == 'macos-15'
        env:
          CC:  ${{ env.CC }}
          CXX: ${{ env.CXX }}
          FC:  ${{ env.FC }}
          F77: ${{ env.F77 }}
          CFLAGS:   ${{ env.CFLAGS }}
          CXXFLAGS: ${{ env.CXXFLAGS }}
          FFLAGS:   ${{ env.FFLAGS }}
          LDFLAGS:  ${{ env.LDFLAGS }}
        run: |
          ./bootstrap
          ./configure --prefix=$PWD ${{ matrix.config_flags }}
          make install
          if [ -f lib/sme_synth.so.darwin.aarch64.64 ]; then
            echo 'Moving aarch to arm'
            mv -v lib/sme_synth.so.darwin.aarch64.64 lib/sme_synth.so.darwin.arm64.64
          fi
          ls lib

      - name: Manage dependence libraries (MacOS; fix dylib names)
        if: matrix.runs_on == 'macos-13' || matrix.runs_on == 'macos-15'
        run: |
          set -eux
          cd lib

          # 拷贝 gfortran/quadmath/gcc_s/stdc++ 动态库
          copy_one() {
            local name="$1"
            local p="$($FC -print-file-name=$name || true)"
            [ -f "$p" ] && cp -v "$p" . || true
          }
          copy_one libgfortran.dylib
          copy_one libquadmath.dylib
          copy_one libgcc_s.1.1.dylib

          # libstdc++ 由 g++ 提供（有时路径不同，逐一尝试）
          STDCPP="$($CXX -print-file-name=libstdc++.6.dylib || true)"
          [ -f "$STDCPP" ] && cp -v "$STDCPP" . || true

          # 用 @rpath/@loader_path 修正 install_name，避免硬编码到 Homebrew 路径
          fix_id() { [ -f "$1" ] && install_name_tool -id "@rpath/$1" "$1" || true ; }
          fix_id libgfortran.dylib
          fix_id libquadmath.dylib
          fix_id libgcc_s.1.1.dylib
          fix_id libstdc++.6.dylib

          # 你的主库名按实际调整（示例：libsme.dylib / libsme.5.dylib）
          for target in libsme.dylib libsme.5.dylib; do
            [ -f "$target" ] || continue
            install_name_tool -id "@rpath/$target" "$target" || true
            for dep in libgfortran.dylib libquadmath.dylib libgcc_s.1.1.dylib libstdc++.6.dylib; do
              [ -f "$dep" ] || continue
              # 将对 Homebrew 绝对路径的引用改到随包的相对位置
              install_name_tool -change "$(otool -L "$target" | awk '/'"$dep"'/ {print $1}')" "@loader_path/$dep" "$target" || true
            done
            otool -L "$target" || true
          done

          install_name_tool -id $PWD/libsme.dylib libsme.dylib
          install_name_tool -id $PWD/libsme.5.dylib libsme.5.dylib
          if [ "${{ matrix.arch }}" = "x86_64" ]; then
            install_name_tool -id $PWD/sme_synth.so.darwin.x86_64.64 sme_synth.so.darwin.x86_64.64
          else
            install_name_tool -id $PWD/sme_synth.so.darwin.arm64.64 sme_synth.so.darwin.arm64.64
          fi

      - name: Manage dependence libraries (Ubuntu; copy libgfortran)
        if: matrix.name == 'ubuntu-gfortran'
        run: |
          make -s flib_source
          make -s flib_target
          cp -v $(readlink -f $(make -s flib_source)) $(make -s flib_target)

      - name: Copy libgfortran (Windows)
        if: matrix.name == 'windows-gfortran'
        run: |
          ls $(x86_64-w64-mingw32-gfortran --print-file-name=)libgfortran-?.dll
          dirname $(make -s flib_target) 
          cp -v $(readlink -f $(ls $(x86_64-w64-mingw32-gfortran --print-file-name=)libgfortran-?.dll)) $(dirname $(make -s flib_target))

      - name: Zip data # This would actually build your project, using zip for an example artifact
        run: zip -r ${{ matrix.name }} ${{ matrix.outputs }}

      - name: Archive compiled library
        uses: actions/upload-artifact@v4
        with:
          name: library-${{ matrix.name }}
          path: ${{ matrix.name }}.zip

      # - name: Test Library (MacOS)
      #   if: matrix.runs_on == 'macos-13' || matrix.runs_on == 'macos-15'
      #   run: |
      #     python3 -m venv .venv
      #     . .venv/bin/activate
      #     python -m pip install -r test/requirements.txt
      #     cd pymodule
      #     python setup.py build_ext --inplace
      #     python -m pytest
        
      - name: Test Library (Others)
        if: matrix.name != 'windows-gfortran' # && matrix.runs_on != 'macos-13' && matrix.runs_on != 'macos-15'
        run: |
          python3 -m venv .venv
          . .venv/bin/activate
          unset CC CXX || true
          python -m pip install -U pip setuptools wheel
          python -m pip install -r test/requirements.txt
          cd pymodule
          python setup.py build_ext --inplace
          cd ..
          python -m pytest

      # - name: Test Library
      #   if: matrix.name != 'windows-gfortran'
      #   run: python3 -m pytest

      - name: Upload Debug Spectrum
        uses: actions/upload-artifact@v4
        with:
          name: debug_radiative_transfer_${{matrix.name}}.npz
          path: ./debug_radiative_transfer.npz

      - name: Upload Release Asset
        if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.publish == 'true')
        id: upload-release-asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create_release.outputs.upload_url }} # This pulls from the CREATE RELEASE step above, referencing it's ID to get its outputs object, which include a `upload_url`. See this blog post for more info: https://jasonet.co/posts/new-features-of-github-actions/#passing-data-to-future-steps
          asset_path: ./${{ matrix.name }}.zip
          asset_name: ${{ matrix.name }}.zip
          asset_content_type: application/zip

  upload_release_asset:
    runs-on: ubuntu-latest
    needs: [build, manylinux-build, create_release]
    if: ${{ needs.create_release_job.result == 'success' }}   # 只有上游成功才上传
    permissions:
      contents: write
    # strategy:
    #   matrix:
    #     name: [linux-x64, macos-arm64]   # 与 build 的矩阵一致
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: "*.zip"             # 把本次运行里所有 artifact 都拉下来
          path: dist               # 统一放到 dist/
          merge-multiple: true     # 多个 artifact 合并到一个目录

      - name: List files to be uploaded
        run: ls -al dist

      - name: Upload all .zip to the release
        uses: softprops/action-gh-release@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.create_release_job.outputs.tag }}   # 与上面创建的 tag 保持一致
          draft: false
          prerelease: true
          files: dist/*.zip