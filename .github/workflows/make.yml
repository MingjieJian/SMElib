name: make

permissions:
  contents: write

on:
  push:
    branches: [master]
  pull_request:
    branches: [master]
  workflow_dispatch:
    inputs:
      publish:
        description: 'Upload to GitHub Release?'
        required: false
        default: 'false'   # 手动触发默认不发布
        type: choice
        options: ['false','true']
        
env:
  # Customize the CMake build type here (Release, Debug, RelWithDebInfo, etc.)
  BUILD_TYPE: Release

jobs:

  manylinux-build:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include: 
          - name: gfortran
            container: manylinux2014_x86_64
            compiler: gfortran
            makefile: Makefile.am

    steps:
      - uses: actions/checkout@v4

      - name: Build & test inside manylinux
        env:
          DOCKER_IMAGE: quay.io/pypa/${{ matrix.container }}
          MAKEFILE: ${{ matrix.makefile }}
          COMPILER: ${{ matrix.compiler }}
          OUT_ZIP: ${{ matrix.container }}-${{ matrix.name }}.zip
        run: |
          set -eux
          docker pull "$DOCKER_IMAGE"
          docker run --rm \
          -v "$GITHUB_WORKSPACE":/work -w /work \
          "$DOCKER_IMAGE" \
          bash -lc '
            set -eux
            yum install -y zip python3-pip python3-devel
            # git clone https://github.com/MingjieJian/SMElib .
            
            # Replace Makefile (optinal)
            if [ "${{ matrix.makefile }}" != "Makefile.am" ]; then
              rm -f Makefile.am 
              mv "${{ matrix.makefile }}" Makefile.am
            fi
            ./bootstrap
            ./configure --prefix=$PWD
            make install
            
            # Copy libgfortran
            if [ "${{ matrix.compiler }}" = "gfortran" ]; then
              make -s flib_target
              cp -v "$(readlink -f "$(make -s flib_source)")" "$(make -s flib_target)"
            fi
            ls -l lib
            zip -r "${{ matrix.container }}-${{ matrix.name }}.zip" lib share
          '

      - name: Test library
        run: |
            pip3 install -r test/requirements.txt
            cd pymodule
            python setup.py build_ext --inplace
            cd ..
            python -m pytest

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.name }}          
          path: |
            ./*.zip
            ./debug_radiative_transfer.npz
            ./sme_synth.stdout.txt
            ./sme_synth.params
          if-no-files-found: ignore

  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: ubuntu-gfortran
            runs_on: ubuntu-latest
            packages: gfortran python3-dev
            outputs: lib share
            makefile: Makefile.am
          - name: windows-gfortran
            runs_on: ubuntu-latest
            packages: gfortran mingw-w64 mingw-w64-tools mingw-w64-common gfortran-mingw-w64 gfortran-mingw-w64-x86-64 gcc-mingw-w64 gcc-mingw-w64-x86-64 g++-mingw-w64 g++-mingw-w64-x86-64 python3-dev
            cxx: x86_64-w64-mingw32-gcc
            f77: x86_64-w64-mingw32-gfortran
            config_flags: --build=x86_64-pc-linux-gnu --host=x86_64-w64-mingw32
            outputs: bin share
            makefile: Makefile.am
          - name: macos-x86_64-gfortran
            runs_on: macos-13
            arch: x86_64
            packages: automake libtool gcc
            outputs: lib share
            makefile: Makefile.am
          - name: macos-arm64-gfortran
            runs_on: macos-15
            arch: arm64
            packages: automake libtool gcc
            outputs: lib share
            makefile: Makefile.am

    # The CMake configure and build commands are platform agnostic and should work equally
    # well on Windows or Mac.  You can convert this to a matrix build if you need
    # cross-platform coverage.
    # See: https://docs.github.com/en/free-pro-team@latest/actions/learn-github-actions/managing-complex-workflows#using-a-build-matrix
    runs-on: ${{ matrix.runs_on }}
      
    steps:
      - uses: actions/checkout@v2

      - name: Install packages (Ubuntu)
        if: matrix.runs_on == 'ubuntu-latest'
        run: sudo apt-get install -y ${{ matrix.packages }}

      - name: Install packages (MacOS)
        if: matrix.runs_on == 'macos-13' || matrix.runs_on == 'macos-15'
        run: |
          brew update
          brew tap ${{ matrix.taps }}
          brew install ${{ matrix.packages }}
      - name: Select GNU compilers (macOS)
        if: matrix.runs_on == 'macos-13' || matrix.runs_on == 'macos-15'
        run: |
          BREW_PREFIX="$(brew --prefix)"
          # gfortran 通常有无版本号两个名字，取到主版本号以匹配 gcc/g++
          FVER="$($BREW_PREFIX/bin/gfortran -dumpversion | cut -d. -f1 || echo 14)"
          echo "CC=$BREW_PREFIX/bin/gcc-$FVER"       >> $GITHUB_ENV
          echo "CXX=$BREW_PREFIX/bin/g++-$FVER"      >> $GITHUB_ENV
          # gfortran 可能有无版本号，可都尝试
          if [ -x "$BREW_PREFIX/bin/gfortran-$FVER" ]; then
            echo "FC=$BREW_PREFIX/bin/gfortran-$FVER" >> $GITHUB_ENV
            echo "F77=$BREW_PREFIX/bin/gfortran-$FVER" >> $GITHUB_ENV
          else
            echo "FC=$BREW_PREFIX/bin/gfortran" >> $GITHUB_ENV
            echo "F77=$BREW_PREFIX/bin/gfortran" >> $GITHUB_ENV
          fi
          # 架构与最小系统版本：按矩阵 arch 区分
          if [ "${{ matrix.arch }}" = "x86_64" ]; then
            echo "CFLAGS=-O3 -arch x86_64 -mmacosx-version-min=11.0"   >> $GITHUB_ENV
            echo "CXXFLAGS=-O3 -arch x86_64 -mmacosx-version-min=11.0" >> $GITHUB_ENV
            echo "FFLAGS=-O3 -arch x86_64 -mmacosx-version-min=11.0"   >> $GITHUB_ENV
            echo "LDFLAGS=-arch x86_64 -mmacosx-version-min=11.0"      >> $GITHUB_ENV
          else
            echo "CFLAGS=-O3 -arch arm64 -mmacosx-version-min=12.0"    >> $GITHUB_ENV
            echo "CXXFLAGS=-O3 -arch arm64 -mmacosx-version-min=12.0"  >> $GITHUB_ENV
            echo "FFLAGS=-O3 -arch arm64 -mmacosx-version-min=12.0"    >> $GITHUB_ENV
            echo "LDFLAGS=-arch arm64 -mmacosx-version-min=12.0"       >> $GITHUB_ENV
          fi

      - name: Replace Makefile.am
        if: matrix.makefile != 'Makefile.am'
        run: |
          rm Makefile.am
          mv ${{ matrix.makefile }} Makefile.am

      - name: Run Bootstrap, Configure and install (Ubuntu)
        if: matrix.runs_on == 'ubuntu-latest'
        env:
          CXX: ${{ matrix.cxx }}
          F77: ${{ matrix.f77 }}
        run: |
          ./bootstrap 
          ./configure --prefix=$PWD ${{ matrix.config_flags }}
          make install

      - name: Run Bootstrap, Configure and install (MacOS)
        if: matrix.runs_on == 'macos-13' || matrix.runs_on == 'macos-15'
        env:
          CC:  ${{ env.CC }}
          CXX: ${{ env.CXX }}
          FC:  ${{ env.FC }}
          F77: ${{ env.F77 }}
          CFLAGS:   ${{ env.CFLAGS }}
          CXXFLAGS: ${{ env.CXXFLAGS }}
          FFLAGS:   ${{ env.FFLAGS }}
          LDFLAGS:  ${{ env.LDFLAGS }}
        run: |
          ./bootstrap
          ./configure --prefix=$PWD ${{ matrix.config_flags }}
          make install
          if [ -f lib/sme_synth.so.darwin.aarch64.64 ]; then
            echo 'Moving aarch to arm'
            mv -v lib/sme_synth.so.darwin.aarch64.64 lib/sme_synth.so.darwin.arm64.64
          fi
          ls lib

      - name: Manage dependence libraries (MacOS; fix dylib names)
        if: matrix.runs_on == 'macos-13' || matrix.runs_on == 'macos-15'
        run: |
          set -eux
          cd lib

          otool -L libsme.dylib

          # 这些依赖随包一起带
          need_deps=(libgfortran.5.dylib libquadmath.0.dylib libstdc++.6.dylib libgcc_s.1.1.dylib)

          # 1) 尽量从编译器位置把依赖拷到当前目录
          copy_from_cc() {  # $1=命令($FC/$CXX), $2=库名
            local p
            p="$($1 -print-file-name=$2 2>/dev/null || true)"
            [ -n "$p" ] && [ -f "$p" ] && cp -v "$p" . || true
          }
          copy_from_cc "$FC"  libgfortran.5.dylib || copy_from_cc "$FC"  libgfortran.dylib
          copy_from_cc "$FC"  libquadmath.0.dylib || copy_from_cc "$FC"  libquadmath.dylib
          copy_from_cc "$CXX" libstdc++.6.dylib
          copy_from_cc "$FC"  libgcc_s.1.1.dylib

          # 若只有无版本号的 gfortran，补个软链（更推荐拿到真的 .5）
          [ -f libgfortran.5.dylib ] || { [ -f libgfortran.dylib ] && ln -sf libgfortran.dylib libgfortran.5.dylib; }

          # 2) 把这些依赖库自身的 id 设为相对路径
          for d in "${need_deps[@]}"; do
            [ -f "$d" ] && install_name_tool -id "@loader_path/$d" "$d" || true
          done

          # 3) 针对每个目标，把“旧路径”自动查出后改为 @loader_path/xxx
          fix_dep() {  # $1=target, $2=库名(含版本)
            local tgt="$1" dep="$2" repl="@loader_path/$2" old
            [ -f "$tgt" ] || return 0
            old="$(otool -L "$tgt" | awk -v d="$dep" '$1 ~ d {print $1; exit}')"
            [ -n "$old" ] && install_name_tool -change "$old" "$repl" "$tgt" || true
          }

          for T in libsme.dylib libsme.5.dylib sme_synth.so.darwin.*; do
            fix_dep "$T" libgfortran.5.dylib
            fix_dep "$T" libquadmath.0.dylib
            fix_dep "$T" libstdc++.6.dylib
            fix_dep "$T" libgcc_s.1.1.dylib
          done

          # libgfortran 可能还依赖 quadmath/gcc_s，也一并改
          fix_dep libgfortran.5.dylib libquadmath.0.dylib
          fix_dep libgfortran.5.dylib libgcc_s.1.1.dylib

          # 4) 验证：不应再出现 /opt/homebrew 或 /usr/local/opt
          echo "== deps of libsme.dylib ==" && otool -L libsme.dylib
          otool -L libsme.dylib | grep -E '(/opt/homebrew|/usr/local/opt)' && { echo "!! still absolute path"; exit 1; } || true

          # # 拷贝 gfortran/quadmath/gcc_s/stdc++ 动态库
          # copy_one() {
          #   local name="$1"
          #   local p="$($FC -print-file-name=$name || true)"
          #   [ -f "$p" ] && cp -v "$p" . || true
          # }
          # copy_one libgfortran.5.dylib
          # copy_one libgfortran.dylib
          # copy_one libquadmath.dylib
          # copy_one libgcc_s.1.1.dylib

          # # libstdc++ 由 g++ 提供（有时路径不同，逐一尝试）
          # STDCPP="$($CXX -print-file-name=libstdc++.6.dylib || true)"
          # [ -f "$STDCPP" ] && cp -v "$STDCPP" . || true

          # # 用 @rpath/@loader_path 修正 install_name，避免硬编码到 Homebrew 路径
          # fix_id() { [ -f "$1" ] && install_name_tool -id "@rpath/$1" "$1" || true ; }
          # fix_id libgfortran.5.dylib
          # fix_id libgfortran.dylib
          # fix_id libquadmath.dylib
          # fix_id libgcc_s.1.1.dylib
          # fix_id libstdc++.6.dylib

          # 你的主库名按实际调整（示例：libsme.dylib / libsme.5.dylib）
          for target in libsme.dylib libsme.5.dylib; do
            [ -f "$target" ] || continue
            install_name_tool -id "@rpath/$target" "$target" || true
            for dep in libgfortran.dylib libquadmath.dylib libgcc_s.1.1.dylib libstdc++.6.dylib; do
              [ -f "$dep" ] || continue
              # 将对 Homebrew 绝对路径的引用改到随包的相对位置
              install_name_tool -change "$(otool -L "$target" | awk '/'"$dep"'/ {print $1}')" "@loader_path/$dep" "$target" || true
            done
            otool -L "$target" || true
          done

          install_name_tool -id $PWD/libsme.dylib libsme.dylib
          install_name_tool -id $PWD/libsme.5.dylib libsme.5.dylib
          if [ "${{ matrix.arch }}" = "x86_64" ]; then
            install_name_tool -id $PWD/sme_synth.so.darwin.x86_64.64 sme_synth.so.darwin.x86_64.64
          else
            install_name_tool -id $PWD/sme_synth.so.darwin.arm64.64 sme_synth.so.darwin.arm64.64
          fi

      - name: Manage dependence libraries (Ubuntu; copy libgfortran)
        if: matrix.name == 'ubuntu-gfortran'
        run: |
          make -s flib_source
          make -s flib_target
          cp -v $(readlink -f $(make -s flib_source)) $(make -s flib_target)

      - name: Copy libgfortran (Windows)
        if: matrix.name == 'windows-gfortran'
        run: |
          ls $(x86_64-w64-mingw32-gfortran --print-file-name=)libgfortran-?.dll
          dirname $(make -s flib_target) 
          cp -v $(readlink -f $(ls $(x86_64-w64-mingw32-gfortran --print-file-name=)libgfortran-?.dll)) $(dirname $(make -s flib_target))

      - name: Zip data # This would actually build your project, using zip for an example artifact
        run: zip -r ${{ matrix.name }} ${{ matrix.outputs }}

      - name: Archive compiled library
        uses: actions/upload-artifact@v4
        with:
          name: library-${{ matrix.name }}
          path: ${{ matrix.name }}.zip
        
      - name: Test Library
        if: matrix.name != 'windows-gfortran'
        run: |
          python3 -m venv .venv
          . .venv/bin/activate
          unset CC CXX || true
          python -m pip install -U pip setuptools wheel
          python -m pip install -r test/requirements.txt
          cd pymodule
          python setup.py build_ext --inplace
          cd ..
          python -m pytest

      - name: Upload Debug Spectrum
        uses: actions/upload-artifact@v4
        with:
          name: debug_radiative_transfer_${{matrix.name}}.npz
          path: ./debug_radiative_transfer.npz

  create_release:
    needs: [build, manylinux-build]
    if: ${{ (github.event_name == 'push' ||
           (github.event_name == 'workflow_dispatch' && fromJSON(github.event.inputs.publish || 'false')))
         && needs.build.result == 'success'
         && needs['manylinux-build'].result == 'success' }}
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
      tag: ${{ steps.tag_release.outputs.new_tag }}
    steps:
      - uses: actions/checkout@v4
      - name: GitHub Tag
        id: tag_release
        # You may pin to the exact commit or the version.·
        # uses: mathieudutour/github-tag-action@1bab3ab0712cafa42b54c512453487b89bb06504
        uses: mathieudutour/github-tag-action@v6.1
        with:
          # Required for permission to tag the repo.
          github_token: ${{ secrets.GITHUB_TOKEN }}
          # Which type of bump to use when none explicitly provided (default: `patch`).
          # default_bump: # optional, default is patch

      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # This token is provided by Actions, you do not need to create your own token
        with:
          tag_name: ${{ steps.tag_release.outputs.new_tag }}
          release_name: Release ${{ steps.tag_release.outputs.new_tag }}
          draft: false
          prerelease: false

  upload_release_asset:
    runs-on: ubuntu-latest
    needs: [create_release]
    if: ${{ needs.create_release.result == 'success' }}
    permissions:
      contents: write
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: "*"             # 把本次运行里所有 artifact 都拉下来
          path: dist               # 统一放到 dist/
          merge-multiple: true     # 多个 artifact 合并到一个目录

      - name: List files to be uploaded
        run: |
          mv dist/manylinux2014_x86_64-gfortran.zip dist/manylinux2014-x86_64-gfortran.zip 
          ls -al dist

      - name: Upload all .zip to the release
        uses: softprops/action-gh-release@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.create_release.outputs.tag }}
          prerelease: ${{ github.ref_name != 'master' }}
          files: dist/*.zip